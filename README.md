## Introducation
This is Java Virtual Machine implemention completely developed in C language. It could be compiled with GCC compiler in both Linux and Mac OS X platform. Generally this virtual machine runtime implements the same technical level as the original SUN hotspot JVM implementation. It parses class file and interprets the byte code without any optimization technology like JIT.

## Background
Java language might be the most famous and successful modern computer language. As the fourth generation language, it is not like the former traditional languages (such as C, Pascal and C++ etc) which are commonly compiled into machine code running on the specific CPU instructions architecture. One of the most important design goals of Java language is its independency of specific platform, this feature makes Java source code be compiled into some kind of intermediate code running on some common runtime environment, rather than the machine code specific to some platform. As for Java language, the intermediate code is byte code and the runtime environment is the Java Virtual Machine, shortly called as JVM. About two years ago, in order to understand the internal workings of the JVM runtime deeply, I wrote some kind of JVM implementation totally in C language and I published all the source code in this github repository. Actually I have not completed all the JVM development work 100 percent, I only implemented the runtime facilities that allow the class file or jar file to run in the runtime. Generally speaking, this JVM implementation is the same with the initial Hot Spot JVM implementation published by former SUN Microsystem in technical level. Even so, it is still helpful for us to understand the internal workings and we can benefit much from this kind of the fourth generation language runtime. This document introduces the JVM implementation in detail, and I will introduce some of the key concepts later.
![](https://github.com/shaojianqing/vmachine/blob/master/res/architecture.png)
                        1.General Architecture of JVM Runtime

## High-Level Structure of JVM Runtime
The JVM structure could consist of two parts in logic. The first part is the parsing engine which is mainly responsible for loading and parsing class or jar files, and building the class definition map after defining the class instance in memory. The second part is the executing engine which is mainly responsible for fetching and executing the instructions in the form of byte code. Actually for the practical implementation of JVM runtime, the garbage collection mechanism is necessary and much important, it is even the key design component, because the performance and stability depends on the garbage collection mechanism largely.

## Binary Format of Byte Code Class File 
As the JVM ecology develops continuously, more and more other JVM-based languages are invented like Groovy, Scala and Kotlin etc, and the JVM runtime has become some kind of common runtime platform for all of that kinds of languages. Here in order to make all the JVM-based languages run on the JVM runtime, it is necessary for all of them to be compiled into the same byte code class file that follows the same binary format and technique specification. The byte code class file could be seen as the public binary interface between JVM-based languages and JVM runtime. The below part will introduce the internal data structure of the byte code class file in detail.

In the above code block shows the class definition which is actually defined as the traditional structure in C language. The class definition contains all the elements or parts mentioned in the above table including constants pool, field item list, method item list and so on. Since the class file is actually intended to be loaded into memory and in the form of finite byte array, the above class definition is generated and parsed from the byte array in memory loaded from the class file. The detailed steps and mechanism is described in the following section.

## Class Definition Parsing and Organization Mechanism of JVM Runtime
Exactly as shown in the above diagram, initially both the class file or jar file is stored in the file system based on some kind of storage like hard disk or event network disk. Then they are intended to be loaded into the memory in the form of byte array. For jar file, it needs to be uncompressed and gets multiply class byte arrays, while for class file, it is loaded in the form of byte array directly. After getting the byte array of the class file in the memory, the parsing function starts to parse the byte array by sliding on the byte array and reading the data from the byte array. In practice, the slider could read short, integer or sub byte array like string type. As illustrated in the below code block, the defineClass function takes the byte array pointer as its input, and returns the Class definition pointer as its output.

In the parsing process, the input byte array pointer itself plays the role of slider. Since it is the pointer in C language, and as we can understand, the pointer itself could perform memory address operation of moving up or moving down on the memory. In this way, the data pointer slides on the memory address, reads values and assigns the values to the class definition sequentially. So we can naturally understand the whole process of parsing class file and constructing class definition precisely.

Once constructing the class definition in the memory, the class definition will be put into the Class Definition Map with the class name as the key and the class definition itself as the value. In the above scene, Vehicle is the parent class of Car and Truck class, and both Car and Truck class consist of Engine Class. This scene is very simple and typical object oriented case. Actually as for the class definition and implementation, the superClassName property has the value of the full name of Vehicle, here it is the string of  "com/sys/data/Vehicle", this means the superClassName property points to the parent class Vehicle. Similarly, since both Car and Truck have the field of Engine, there must be the field definition in the field list. And the descriptor property in the field definition has the value of the full name of Engine, here it is the string of "com/sys/data/Engine".

Based on the above analysis, we can understand how JVM runtime organizes a lot of class definition in the memory and how multiply class definition connects each other to maintain the relationship. That mechanism is actually the meta space in modern JVM implementation like the Oracle JVM implementation.

## Instruction Execution Mechanism of JVM Runtime
Generally speaking, there exist two kinds of instruction execution mechanism: the register-based instruction and the stack-based instruction.Just as shown in the below two diagrams, the register-based instruction directly accesses the registers inside the CPU, and does the arithmetic or logic operation with the registers naturally. Based on its execution mechanism and the fact that the registers is the fastest and much faster than memory when reading or writing, register-based instruction generally could have much higher performance with less reading or writing operation on the memory. Actually for most of the compiling languages such as C, C++, Pascal and so on, they are commonly compiled into machine code which is actually the register-based instruction set. But the disadvantages is obvious meanwhile, since the register-based instruction is specific to the particular CPU instruction set like intel x86 instruction set, it is almost impossible to have cross-platform running features in the binary level. Commonly, this kind of execution mechanism plays the underlying execution role in the computer technology stack.

While it is hard for the register-based instruction to be independent of some specific CPU platform, actually it is easier for the stack-based instruction to be independent enough and have the cross-platform feature in the binary level. Since stack is some kind of data area in the memory, and memory structure almost keeps the same even in different CPU platform, the common implementation could introduce some kind of intermediate instruction set which could be interpreted by some runtime. In this design, the runtime could be specific to some particular CPU platform or Operating System, but the program based on the intermediate instruction set could be independent of any specific CPU platform or Operating System. This is the basic design philosophy for JVM runtime from the former SUN Microsystem, as well as the Common Language Runtime from Microsoft. Actually both JVM runtime and Common Language Runtime have become independent of platform and can support multiply languages until now, and the basis is due to the intermediate instruction set and the related runtime infrastructure which makes them a common platform for the Internet Application to run many kinds of programs.

As shown in the above diagram, for stack-based instruction, the main execution mechanism is based on the operations with the memory, particularly the memory structure stack. And the instruction set could be simple enough for execution, while some complex and platform related operations could be implemented with the native interface which is usually written with some native languages like C or C++. In JVM runtime, all the instructions are defined by only one byte, that is why the JVM instruction is called as byte code instruction here.

## Object Oriented Style In C Language
As we all know that C language is the procedure oriented language and not support the object oriented style natively. But actually we could design and develop with C language in object oriented style in practice and it sounds interesting, isn't it ? Since object oriented style can reduce the complexity of the system analysis and simplify the domain modeling process, I finally designed and developed my JVM implementation with C language in object oriented style. The following part will introduce this perspective and thinking style in detail.

As shown in the above diagram, the object could be some kind of model mapping to the entity in the real world. So similarly the object has two parts which are properties and functions, and could be seen as the combination of that two parts. Properties mean the data or statement of the object, while functions mean the behavior of the object. Finally with these two parts, the object could work as a whole in itself scope, and multiply objects could work together to do some complex things further more. 

Based on the above analysis, we can conclude that if only some language has the feature that could organize the properties and functions, and combine them into some kind of unified data type or structure, it could be convenient to develop in the object oriented style with that language. As for C language, there exist two features that are the key factors for object oriented style. They are struct data type and function pointer. In the below part, they will be introduced in detail.

## Execution Engine Mechanism In JVM Runtime
As we all know that, the JVM runtime is designed to execute the byte code instructions, so the execution engine plays the most important role in the JVM architecture. Just as mentioned about the parsing engine, the class file is loaded from the storage and the class definition is parsed and maintained in the JVM memory. And something is much critical is that the byte code instructions are parsed as the attributes in the method. The parsing process is shown in the following code block:

In JVM specification, method contains multiply attributes, and there is one kind of attribute whose attribute name is "Code", actually this attribute is full of byte code instructions. So naturally the content of this attribute is parsed and copied to the codeData property and codeLength property to record the byte length of the codeData in method data structure. When executing the byte code instructions, the codeData will be passed to the ByteReader which provides a variety of function convenient for processing byte array efficiently.

① The thread running loop fetches the operation code of the byte code instruction from the byte reader which maintains the instructions sequence coming from the method definition.

② Then gets the instruction from the Instruction Table. The instruction data structure contains five parts to support execution and will be described in detail in the below table.

③ The thread running loop calls the Fetcher function pointer to fetch the corresponding operands necessary for the instruction execution with some specific byte code instruction.

④ Finally the thread running loop calls the Processor function pointer to execute the instruction which may operate the operand stack or local variable table if necessary.

From the above diagram, it is clear to understand the general process of instruction execution mechanism here. When executing, the thread running loop fetches the byte code instruction and operands sequentially and frequently, and then calls the corresponding  processor function according to the different byte code instructions. Since JVM instruction is based on the stack rather than the register, the processor will frequently access or operate the operand stack data structure in the most of the instructions, while for some specific instructions, it is necessary to store or load some parameters in the local variables data structure. The detailed implementation is shown in the below part.

As shown in the above code blocks, local variables is just some kind of array container that stores or loads data based on the array operation, so it is necessary to pass the index as the parameter. While operand stack is of course some kind of stack container that pushes or pops data always on the stack top, so it is totally not necessary to pass any kind of parameter to point out the position here. Actually, both local variables and operand stack are much important for instruction execution, they actually form the micro runtime environment which is called as stack frame in JVM runtime environment.

The load instructions actually load data values from local variables and push them into the operand stack. And correspondingly, the strore instructions pop the data values from the operand stack and store them into the local variables.

Almost all the arithmetic operation instructions in JVM is like the above code logic, they are all based on the operand stack to load and store data values.